# 행의 수가 N 이고 열의 수가 M인 격자의 각 칸에 1부터 N×M까지의 번호가 첫 행부터 시작하여 차례로 부여되어 있다. 
# 격자의 어떤 칸은 ○ 표시가 되어 있다. 
# (단, 1번 칸과 N×M번 칸은 ○ 표시가 되어 있지 않다. 또한, ○ 표시가 되어 있는 칸은 최대 한 개이다. 즉, ○ 표시가 된 칸 이 없을 수도 있다.)

# 격자의 1번 칸에서 출발한 어떤 로봇이 아래의 두 조건을 만족하면서 N×M번 칸으로 가고자 한다.
#   조건 1: 로봇은 한 번에 오른쪽에 인접한 칸 또는 아래에 인접한 칸으로만 이동할 수 있다. (즉, 대각선 방향으로는 이동할 수 없다.)
#   조건 2: 격자에 ○로 표시된 칸이 있는 경우엔 로봇은 그 칸을 반드시 지나가야 한다.

# 격자에 관한 정보가 주어질 때 로봇이 앞에서 설명한 두 조건을 만족하면서 이동할 수 있는 서로 다른 경로가 총 몇 개나 되는지 찾는 프로그램을 작성하라.

# 입력

# 첫째 줄 에는 격자의 행의 수와 열의 수를 나타내는 두 정수 N 과 M ( 1 ≤ N,M ≤ 15), 
# 그리고 ○로 표시 된 칸의 번호를 나타내는 정수 K( K=0 또는 1 < K < N×M)가 차례로 주어지며, 각 값은 공백으로 구분된다. 
# K의 값이 0인 경우도 있는 데, 이는 ○로 표시된 칸이 없음을 의미한다.

# 로봇의 현재위치를 전역변수로 우선 선언한다.
cur_x = 0
cur_y = 0

# (현재위치에서) 목적지까지의 경우의 수를 반환하는 함수를 정의한다.
def calc(destNum):
    # 함수 내에서 cur_x, cur_y 변수가 전역변수임을 명시한다.
    global cur_x, cur_y

    # 목적지의 번호에서 목적지의 x, y 좌표를 산출한다.
    destNum -= 1
    dest_x = destNum % M
    dest_y = int(destNum / M)

    # 출발지에서 목적지까지 x, y 거리 만큼의 2차원 배열을 생성하고,
    # x 또는 y가 0일 경우는 1을, 그 외에는 바로 윗칸과 왼쪽칸의 수를 합하여 칸을 채운다.
    # 예를 들어 문제에서의 예처럼 1번에서 8번까지 가야할 경우,
    # 2차원 배열은 다음과 같이 생성 될 것이다.
    #   1 1 1
    #   1 2 3
    # 이때 가장 오른쪽 아래의 3이 목적지까지 가는 경로의 경우의 수이다.
    matrix = [[0] * (dest_x - cur_x + 1) for i in range(dest_y - cur_y + 1)]
    for y in range(len(matrix)):
        for x in range(len(matrix[y])):
            # 삼항연산자)
            # x 또는 y가 0이면 matrix[y][x]에 1을 할당하고,
            # 그렇지 않다면 matrix[y][x]에 matrix[y-1][x] + matrix[y][x - 1]을 할당한다.
            matrix[y][x] = 1 if x == 0 or y == 0 else matrix[y - 1][x] + matrix[y][x - 1]

    # 로봇의 현재 x, y 좌표를 
    # 도착한 목적지의 x, y 좌표로 바꿔준다.
    cur_x = dest_x
    cur_y = dest_y

    # 배열에서 인덱스가 음수일 경우
    # lastIndexOf로 간주된다.
    # -1일 경우 배열의 마지막 요소가 반환되며,
    # 이 경우 2차원 배열의 마지막 행의 마지막 요소가 반환된다.
    return matrix[-1][-1]

N, M, K = map(int, input().split())

# 경유지가 없을 경우 ( K == 0 ) 그대로 마지막 칸 ( N * M ) 까지의 경로의 수를 반환하고,
# 경유지가 존재할 경우 (출발지에서 경유지까지의 경우의 수 * 경유지에서 마지막 칸까지의 경우의 수)를 반환한다.
print( calc(N * M) if K == 0 else calc(K) * calc(N * M))